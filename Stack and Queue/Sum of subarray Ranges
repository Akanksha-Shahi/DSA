#include<bits/stdc++.h>
using namespace std;
const int mod = 1e9+7;
// brute:
int sum( vector<int> &arr, int n ){
    int sum1 =0;
    for( int i =0; i<n; i++){
        int mini = arr[i];
        int maxi = arr[i];
        for( int j =i; j<n; j++){
            mini = min( mini, arr[j]);
            maxi = max( maxi, arr[j]);
            sum1 += (maxi - mini);
        }
    }
    return sum;
}
// optimal: sum of subarray maximum - sum of subarray minimum
vector<int> findPse( vector<int> &arr){
    int n = arr.size();
    vector<int> psee(n);
    stack<int> st;
    for( int i =0; i<n; i++){
        while( !st.empty() && arr[st.top()] > arr[i]){
            st.pop();
        }
        psee[i]= st.empty( ) ? -1 : st.top();
        st.push(i);
    }
    return psee;
}
vector<int> findNse( vector<int> &arr){
    int n = arr.size();
    vector<int> nsee(n);
    stack<int> st;
    for( int i =n-1; i>=0; i--){
        while( !st.empty() && arr[st.top()] >= arr[i]){
            st.pop();
        }
        nsee[i]= st.empty( ) ? n : st.top();
        st.push(i);
    }
    return nsee;
}
int subMin( vector<int> &arr, int n){
    int total= 0;
    stack<int> st;
    vector<int> pse(n), nse(n);
    nse = findNse(arr);
    pse = findPse(arr);
    mod = int(1e9+7);
    for( int i =0; i<n; i++){
        left = i -pse[i];
        right = nse[i]-i;
        total = (total + (left * right % mod) * arr[i] % mod) % mod;

    }
    return total;
}
int subMax( vector<int> &arr, int n){
    int total= 0;
    stack<int> st;
    vector<int> pse(n), nse(n);
    nse = findNse(arr);
    pse = findPse(arr);
    mod = int(1e9+7);
    for( int i =0; i<n; i++){
        left = i -pse[i];
        right = nse[i]-i;
        total =(total + (left * right % mod) * arr[i] % mod) % mod;


    }
    return total;
}
int subRange( vector<int> &arr, int n){
    return ( subMax(arr, n) - subMin(arr, n) + mod)%mod;
}
