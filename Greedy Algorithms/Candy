#include<bits/stdc++.h>
using namespace std;
// brute: look for left and right neighbours and then find max
int func( vector<int> &ratings){
    vector<int> &left;
    vector<int> &right;
    left[0]=1, right[n-1]=1;
    for( int i =1; i< ratings.size(); i++){
        if( ratings[i] > ratings[i-1]) left[i] = left[i-1] +1;
        else left[i] =1;
    }
    for( int i = ratings.size()-2; i>=0; i--){
        if( ratings[i] > ratings[i+1]) right[i] = right[i+1] +1;
        else right[i] =1;
    }
    int sum =0;
    for( int i =0; i<ratings.size(); i++){
        sum += max(left[i], right[i]);
    }
    return sum;
}

// better: by removing right array
int func2( vector<int> &ratings){
    vector<int> &left;
    left[0]=1;
    for( int i =1; i< ratings.size(); i++){
        if( ratings[i] > ratings[i-1]) left[i] = left[i-1] +1;
        else left[i] =1;
    }
    int curr =1, right =1, sum =max(1, left[n-1]);
    for( int i = ratings.size()-2; i>=0; i--){
        if( ratings[i] > ratings[i+1]) curr = right+1; right =curr;
        else curr =1;
        sum += max(left[i], curr);
    }
    return sum;
}

// optimal: using the concept of slope
int func3( vector<int> &ratings){
    int sum =1, i=1;
    while( i< ratings.size()){
        if( ratings[i] == ratings[i-1]){
            sum++;
            i++;
            continue;
        }
        int peak =1;
        while( i< ratings.size() && ratings[i]> ratings[i-1]){
            peak++;
            sum += peak;
            i++;
        }
        int down =1;
        while( i< ratings.size() && ratings[i]< ratings[i-1]){
            sum += down;
            i++; 
            down++;
        }
        if( down>peak) sum += down -peak;
    }
    return sum;
}
int main(){
    vector<int> ratings = {1,0,2};
    cout << func3(ratings) << endl;
    return 0;
}
