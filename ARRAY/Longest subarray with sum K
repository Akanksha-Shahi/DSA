// brute force solution: generate all subrrays and check for longest subarray with sum K
#include <iostream>
#include<vector>
using namespace std;
int longestSubarray(vector<int> &arr, int k){
    int len =0;
    for ( int i=0; i<arr.size(); i++){
        for (int j=i; j<arr.size(); j++){
            int sum =0;
            for ( int k=i; k<=j; k++){
                sum += arr[k]; // calculates the sum of the subarray from index i to j
            }
            if ( sum == k){
                len = max(len, j-i+1); // updates the length of the longest subarray if needed
            }}}
        return len; // returns the length of the longest subarray with sum K
}
int main(){
    int n, k;
    cout<<" enter the size of the array:";
    cin>> n;
    vector<int> arr(n);
    cout<<" enter the elements of the array:";
    for ( int i=0; i<n; i++){
        cin>> arr[i]; // reads the elements of the array
    }
    cout<<" enter the value of k:";
    cin>> k; // reads the value of k
    int result = longestSubarray(arr, k);
    cout<<" the length of the longest subarray with sum k is: "<< result<< endl;
    return 0;
}


// better solution: will use prefix sum and hashing(for positive numbers only)
#include <iostream>
#include<vector>
#include<map>
using namespace std;
int longestSubarray( vector<int> a, long long k){
    map<long long, int> preSumMap; // map to store prefix sums and their first occurrence index
    long long sum = 0; // variable to store the current prefix sum
    int maxLen = 0; // variable to store the length of the longest subarray with sum k
    for ( int i=0; i<a.size(); i++){
        sum += a[i]; // updates the current prefix sum
        if ( sum == k){
            maxLen = max(maxLen, i + 1); // updates maxLen if the current prefix sum equals k
        }
        int rem = sum - k;
        if ( preSumMap.find(rem) != preSumMap.end()){
            int len = i - preSumMap[rem]; // calculates the length of the subarray with sum k
            maxLen = max(maxLen, len); // updates maxLen if needed
        }
        preSumMap[sum] = i; // stores the first occurrence index of the current prefix sum
    }
    return maxLen; // returns the length of the longest subarray with sum k
}
int main(){
    int n;
    long long k;
    cout<<" enter the size of the array:";
    cin>> n;
    vector<int> arr(n);
    cout<<" enter the elements of the array:";
    for ( int i=0; i<n; i++){
        cin>> arr[i]; // reads the elements of the array
    }
    cout<<" enter the value of k:";
    cin>> k; // reads the value of k
    int result = longestSubarray(arr, k);
    cout<<" the length of the longest subarray with sum k is: "<< result<< endl;
    return 0;
}


// better solution: will use prefix sum and hashing(for 0 as well as negative numbers)
#include <iostream>
#include<vector>
#include<map>
using namespace std;
int longestSubarray( vector<int> a, long long k){
    map<long long, int> preSumMap; // map to store prefix sums and their first occurrence index
    long long sum = 0; // variable to store the current prefix sum
    int maxLen = 0; // variable to store the length of the longest subarray with sum k
    for ( int i=0; i<a.size(); i++){
        sum += a[i]; // updates the current prefix sum
        if ( sum == k){
            maxLen = max(maxLen, i + 1); // updates maxLen if the current prefix sum equals k
        }
        long long  rem = sum - k;
        if ( preSumMap.find(rem) != preSumMap.end()){
            int len = i - preSumMap[rem]; // calculates the length of the subarray with sum k
            maxLen = max(maxLen, len); // updates maxLen if needed
        }
        if (preSumMap.find(sum) == preSumMap.end()) // stores the first occurrence index of the current prefix sum
            preSumMap[sum] = i;
    }
    return maxLen; // returns the length of the longest subarray with sum k
}
int main(){
    int n;
    long long k;
    cout<<" enter the size of the array:";
    cin>> n;
    vector<int> arr(n);
    cout<<" enter the elements of the array:";
    for ( int i=0; i<n; i++){
        cin>> arr[i]; // reads the elements of the array
    }
    cout<<" enter the value of k:";
    cin>> k; // reads the value of k
    int result = longestSubarray(arr, k);
    cout<<" the length of the longest subarray with sum k is: "<< result<< endl;
    return 0;
}




// optimal solution : will use 2 pointer approach( for + and 0 only)
#include <iostream>
#include<vector>
using namespace std;
int longestSubarray( vector<int> a, long long k){
    int left =0, right = 0;
    long long sum = a[0];
    int maxLen=0;
    int n = a.size();
    while ( right <n){
        while (left <= right && sum> k){
            sum-=a[left];
            left ++;
        }
        if ( sum ==k){
            maxLen= max(maxLen, right-left+1); // updates maxLen if the current window sum equals k
        }
        right ++;
        if ( right <n) sum += a[right]; // expands the window by moving the right pointer
}
return maxLen; // returns the length of the longest subarray with sum k
}   
int main(){
    int n;
    long long k;
    cout<<" enter the size of the array:";
    cin>> n;
    vector<int> arr(n);
    cout<<" enter the elements of the array:";
    for ( int i=0; i<n; i++){
        cin>> arr[i]; // reads the elements of the array
    }
    cout<<" enter the value of k:";
    cin>> k; // reads the value of k
    int result = longestSubarray(arr, k);
    cout<<" the length of the longest subarray with sum k is: "<< result<< endl;
    return 0;
}// time complexity : O(2N)   space complexity : O(1)
