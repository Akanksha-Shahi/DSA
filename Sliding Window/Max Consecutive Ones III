#include<iostream>
#include<vector>
using namespace std;
// brute: O(n^2) generate all substrings using 'i' and 'j'
int funcb( vector<int> &nums, int k){
    int maxLen =0;
    for( int i=0; i<nums.size(); i++){
        int zeros =0;
        for( int j=i; j<nums.size(); j++){
            if( nums[j] == 0) zeros++;
            if( zeros > k){
                int len = j - i + 1;
                maxLen = max( maxLen, len);
            }
            else break;    
        }
    }
    return maxLen;
}

// better: o(2n) use two pointer and sliding window
int funcbt( vector<int> &nums, int k){
    int maxlen=0;
    int l=0, r=0;
    int zeros = 0;
    while( r<nums.size()){
        if ( nums[r]==0) zeros++;
        while( zeros > k){
            if ( a[l] == 0) zeros--; left ++;
        }
        if ( zeros <= k){
            int len = r-l+1;
            maxlen = max( len, maxlen);
        }
    r++;  
    }
    return maxlen;
}    

// optimal: O(n) sliding window
int func( vector<int> &nums, int k){
    int maxLen =0;
    int zeros =0;
    int left =0, right =0;
    while( right<nums.size()){
        if( nums[right] == 0) zeros++;
        if( zeros > k){
            if( nums[left] == 0) zeros--;
            left++;
        }
        if ( zeros <= k){
            int len = right - left + 1;
            maxLen = max( maxLen, len);
        }
        right++;
    }
    return maxLen;
}
int main(){
    vector<int> nums= {1,1,1,0,0,0,1,1,1,1,0};
    int k=2;
    int ans= func( nums, k);
    cout<< ans<< endl;
    return 0;
}
